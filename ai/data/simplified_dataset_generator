import random
import json
import os
import re

class TransactionFilterDatasetGenerator:
    def __init__(self):
        self.commands = ['Fetch', 'Get', 'Query', 'Load', 'Read', 'Pull', 'Show', 'List']
        self.orders = ['latest', 'oldest', 'recent', 'earliest', 'most recent']
        self.functions = ['setup function', 'on function', 'off function', 'feedback function']
        self.transaction_words = ['', 'transaction', 'transactions', 'txn', 'txns']
        self.number_words = {
            1: ['one', '1'],
            2: ['two', '2'],
            3: ['three', '3'],
            4: ['four', '4'],
            5: ['five', '5'],
            6: ['six', '6'],
            7: ['seven', '7'],
            8: ['eight', '8'],
            9: ['nine', '9'],
            10: ['ten', '10']
        }
    
    def get_random_count(self):
        """숫자나 단어로 된 카운트 반환"""
        if random.choice([True, False]):  # 숫자를 사용할지 단어를 사용할지 결정
            number = random.randint(1, 10)
            # None, number word 또는 숫자 문자열 중 하나 랜덤 선택
            choices = [None, random.choice(self.number_words[number]), str(number)]
            return random.choice(choices)
        return 'all'
    
    def random_pk(self):
        return ''.join(random.choices('abcdef0123456789', k=130))

    def random_timestamp(self):
        return str(random.randint(1600000000, 1700000000))
    
    def generate_input(self):
        command = random.choice(self.commands)
        transaction_word = random.choice(self.transaction_words)  # 추가된 부분
        
        
        # 조건들 기본적으로 설정
        conditions = []

        # 조건이 없을 경우 None 값으로 대체하고 조건을 생성
        to_address = self.random_pk() if random.choice([True, False]) else None
        from_or_by_address = self.random_pk() if random.choice([True, False]) else None
        func = random.choice(self.functions) if random.choice([True, False]) else None
        timestamp = random.choice([f"after {self.random_timestamp()}", f"before {self.random_timestamp()}"]) if random.choice([True, False]) else None
        order = random.choice(self.orders) if random.choice([True, False]) else None
        
        # 조건이 None이 아니면 추가
        if to_address:
            conditions.append(f"to {to_address}")
        if from_or_by_address:
            if random.choice([True, False]):
                conditions.append(f"from {from_or_by_address}")
            else:
                conditions.append(f"by {from_or_by_address}")
        if func:
            conditions.append(f"{func}")
        if timestamp:
            conditions.append(timestamp)
        if order:
            conditions.append(order)
        
        # 조건이 하나도 없으면, 하나 이상을 강제로 추가 (to, from, timestamp, func, order 중에서)
        if not conditions:
            fallback_filter = random.choice(['to', 'from', 'by', 'func', 'timestamp', 'by_order'])
            if fallback_filter == 'to':
                address = self.random_pk()
                conditions.append(f"to {address}")
            elif fallback_filter == 'from' or 'by':
                address = self.random_pk()
                if random.choice([True, False]):
                    conditions.append(f"from {address}")
                else:
                    conditions.append(f"by {address}")
            elif fallback_filter == 'func':
                func = random.choice(self.functions)
                conditions.append(f"{func}")
            elif fallback_filter == 'timestamp':
                timestamp = random.choice([f"after {self.random_timestamp()}", f"before {self.random_timestamp()}"])
                conditions.append(timestamp)
            elif fallback_filter == 'order':
                conditions.append(random.choice(self.orders))
        
        # count는 1에서 10 사이의 숫자, 없으면 None
        count = self.get_random_count()

        # 조건들을 조합하여 반환
        condition = " ".join(conditions).strip()
        parts = [command]
        if count is not None:
            parts.append(str(count))
        if transaction_word:  # count 다음에 transaction_word 추가
            parts.append(transaction_word)
        parts.append(condition)
        return " ".join(parts).strip()
    
    def generate_output(self, input_text):
        filter_chain = ""
        
        # 입력 텍스트에서 pk 값 추출
        if "to " in input_text:
            pk = input_text.split("to ")[-1].split()[0]
            filter_chain += f".by_pk('{pk}')"
        else:
            filter_chain += ".by_pk(-1)"
        
        if "from " in input_text:
            src_pk = input_text.split("from ")[-1].split()[0]
            filter_chain += f".by_src_pk('{src_pk}')"
        elif "by " in input_text:
            src_pk = input_text.split("by ")[-1].split()[0]
            filter_chain += f".by_src_pk('{src_pk}')"
        else:
            filter_chain += ".by_src_pk(-1)"
        
        if any(func in input_text for func in self.functions):
            func_name = next(func for func in self.functions if func in input_text)
            func_name = func_name.replace(' function', '')
            filter_chain += f".by_func_name('{func_name}')"
        else:
            filter_chain += ".by_func_name(-1)"
        
        if "after " in input_text or "before " in input_text:
            timestamp = input_text.split("after ")[-1].split()[0] if "after " in input_text else input_text.split("before ")[-1].split()[0]
            filter_chain += f".by_timestamp('{timestamp}')"
        else:
            filter_chain += ".by_timestamp(-1)"

        # 시간 순서 키워드 확인
        has_order_keyword = ("most recent" in input_text.lower() or 
                    "earliest" in input_text.lower() or 
                    "oldest" in input_text.lower() or 
                    "latest" in input_text.lower())
        
        input_lower = input_text.lower()
        if "oldest" in input_lower or "earliest" in input_lower:
            filter_chain += ".by_order(0)"
        elif "most recent" in input_lower:
            filter_chain += ".by_order(1)"
        elif "latest" in input_lower or "recent" in input_lower:
            filter_chain += ".by_order(1)"
        else:
            filter_chain += ".by_order(0)"
        
        
        # count 처리
        input_without_transaction = input_text.replace('transaction', '').replace('transactions', '')
        count = None
        for num, words in self.number_words.items():
            for word in words:
                if word in input_without_transaction.lower():
                    count = str(num)
                    break
            if count:
                break

        # 2. 숫자가 없고 시간 순서 키워드가 있으면 count를 1로 설정
        if count is None and has_order_keyword:
            count = "1"
        else:
            has_plural = 'txns' in input_lower or 'transactions' in input_lower
            if 'all' in input_without_transaction.lower() or (has_plural and count is None):
                count = "-1"
            elif count is None:
                count = "-1"

        return f"txn{filter_chain}.get_result({count})"

    
    def generate_dataset(self, n=10):
        dataset = []
        for _ in range(n):
            input_text = self.generate_input()
            output_text = self.generate_output(input_text)
            dataset.append({
                "input": input_text,
                "output": output_text
            })
        return dataset


# Dataset 생성
generator = TransactionFilterDatasetGenerator()
dataset = generator.generate_dataset(2500)

# 파일 경로 설정
project_root = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', '..'))
file_path = os.path.join(project_root, 'ai', 'data', 'raw', 'simplified_generated_dataset.json')
os.makedirs(os.path.dirname(file_path), exist_ok=True)

# JSON 파일로 저장
with open(file_path, 'w') as json_file:
    json.dump({"dataset": dataset}, json_file, indent=4)

print(f"JSON 파일이 {file_path}에 저장되었습니다.")
